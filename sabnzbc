#!/usr/bin/python
import json
import re
import os
import urllib
import curses
import sys
import time
import threading
import datetime
import platform
from curses.textpad import Textbox

# TODO: add queue Add..., action on complete
# TODO: make Textbox handle control characters
# TODO: history view + commands
# TODO: Remember which columns are visible between runs
# TODO: Allow column re-ordering
# TODO: Turn queue win into a pad so we can view large lists in small windows
# TODO: Figure out how to move around that pad
# TODO: Make a readme file and push to github

itemCmds = {
	'd': ['queue&name=delete', None],
	'm': ['switch', 'id'],
	's': ['change_script', 'str'],
	'c': ['change_cat', 'str'],
	'o': ['change_opts', 'str'],
	'y': ['priority', 'str'],
	'p': ['pause', 'id'],
	'r': ['resume', 'id'],
	#'n': ['rename', 'str'] # Not yet implemented on SABnzbd end
	}

queueCmds = {'P': 'pause', 'R': 'resume', 'S': 'shutdown'}

help = '''
=============================================================================
| Item Commands      | Queue Commands      | Column Names                   |
| ------------------ | ------------------- | ------------------------------ |
| d: delete          | P: pause            | t: Status       p: Priority    |
| m: move            | R: resume           | i: Index        c: Category    |
| s: change script   | S: shutdown         | e: ETA          r: MB Left     |
| c: change category |                     | l: Time Left    %: Percentage  |
| o: change options  | Other Commands      | a: Age          b: SAB ID      |
| y: change priority | ------------------- | s: Script       o: Options     |
| p: pause           | q: quit             | g: Message ID   z: Size        |
| r: resume          | h: toggle help      | v: Verbosity    n: Name        |
|                    | t: toggle column    | m: Size (MB)    *: All         |
| ------------------------------------------------------------------------- |
|                    Syntax: command start-stop argument                    |
=============================================================================
'''

class Column(object):
	def __init__(self, sabName, displayName=None, shortName=None, width=10, visible=False):
		self.sabName = sabName
		self.displayName = displayName if displayName else sabName.capitalize()
		self.shortName = shortName if shortName else self.displayName[0].lower()
		self.width = width
		self.visible = visible

def initColumns():
	columns = [
		Column('status', shortName='t', width=11),
		Column('index', '#', 'i', 3, True),
		Column('eta', 'ETA'),
		Column('timeleft', 'Time Left', 'l', 9),
		Column('avg_age', 'Age', width=4),
		Column('script'),
		Column('msgid', 'Message ID', shortName='g'),
		Column('verbosity'),
		Column('mb', 'Size (MB)', 'm'),
		Column('filename', 'Name', width=40, visible=True),
		Column('priority'),
		Column('cat', 'Category', visible=True),
		Column('mbleft', 'MB Left', 'r'),
		Column('percentage', '%', '%'),
		Column('nzo_id', 'SAB ID', 'b', 18),
		Column('unpackopts', 'Options'),
		Column('size', shortName='z')
	]
	# Sanity check
	shortNames = set()
	for column in columns:
		shortName = column.shortName
		if shortName not in shortNames: shortNames.add(shortName)
		else: raise KeyError, 'short name for %s already in use' % column.displayName
	return columns

def log(*args):
	f = open(os.path.expanduser('~/Library/Logs/sabnzbc.log'), 'a')
	f.write(datetime.datetime.now().strftime('%c: '))
	for arg in args: f.write('%s ' % str(arg))
	f.write('\n')
	f.close()

def _getURL(url):
	f = urllib.urlopen(url)
	r = f.read()
	f.close()
	return r

def _getJSON(url):
	return json.loads(_getURL(url))

def _readFile(path):
	f = open(path)
	r = f.read()
	f.close()
	return r

def strWithWidth(s, w):
	return '{0:{1}}'.format(s[:w], w)

def _getConfig():
	system = platform.system()
	if system == 'Darwin': configPath = '~/Library/Application Support/SABnzbd/sabnzbd.ini'
	elif system == 'Unix' or system == 'Linux': configPath ='~/.sabnzbd/sabnzbd.ini'
	elif system == 'Windows':
		winVersion = os.sys.getwindowsversion()
		oldVersions = {(1, 4, 0): "95", (1, 4, 10): "98", (1, 4, 90): "ME", (2, 4, 0): "NT", (2, 5, 0): "2K", (2, 5, 1): "XP", (2, 5, 2): '2003',}
		if winVersion in oldVersions: configPath = '~\\local data\\application data\\sabnzbd\\sabnzbd.ini'
		else: configPath = '~\\AppData\\Local\\sabnzbd\\sabnzbd.ini'
	
	configPath = os.path.expanduser(configPath)
	if not os.path.exists(configPath):
		return (None, None)

	r = _readFile(configPath)
	apiKey = None
	port = None
	for line in r.split('\n'):
		if line.startswith('api_key'):
			apiKey = line.split('=')[1].strip()
		elif line.startswith('port') and not port:
			port = line.split('=')[1].strip()
	return (apiKey, port)

def sendCmd(base, apiKey, cmd, arg1=None, arg2=None):
	s = 'http://%s/api?mode=%s&output=json&apikey=%s' % (base, cmd, apiKey)
	if arg1: s += '&value='  + urllib.quote(arg1)
	if arg2: s += '&value2=' + urllib.quote(arg2)
	#log('sending command', s)
	return _getJSON(s)

def printColumnHeaders(win, columns, y, x):
	#log('printing column headers:', y, x)
	for column in columns:
		try: win.addnstr(y, x, column.displayName, column.width)
		except: pass
		x += column.width + 1

def printQueue(queue, win):
	height, width = win.getmaxyx()
	y, x = win.getbegyx()
	win.clear()
	visibleColumns = [column for column in columns if column.visible]
	colWidth = sum([column.width + 1 for column in visibleColumns])
	win.addstr('status:%s, remaining:%s MB, ETA: %s, speed:%s KB/s available:%s GB' % (queue['status'], queue['mbleft'], queue['eta'], queue['kbpersec'], queue['diskspace1']))
	y += 1
	offset = 0
	printColumnHeaders(win, visibleColumns, y, offset)
	y += 1
	for index, item in enumerate(queue['slots']):
		if y == height:
			y = 2
			x += colWidth
			printColumnHeaders(win, visibleColumns, 1, x)
		if x == width: break
		try:
			offset = 0
			for column in visibleColumns:
				try: win.addnstr(y, x + offset, str(item[column.sabName]), column.width)
				except: pass
				offset += column.width + 1
		except curses.error: pass
		y += 1

def printHelp(win):
	height, width = win.getmaxyx()
	y, x = win.getbegyx()
	row = y + height - help.count('\n')
	for line in help.split('\n'):
		try: win.addnstr(row, x, line, len(line))
		except: pass
		row += 1

def handleCmd(base, apiKey, cmdStr):
	global ids, columns, forceUpdate, helpOn
	cmdName = cmdStr[0]

	if cmdName == 'q':
		sys.exit(0)
	
	if cmdName == 'h':
		helpOn = not helpOn
	
	cmdStr = cmdStr[1:].strip()
	
	if cmdName == 't':
		if cmdStr[0] == '*':
			if any([not column.visible for column in columns]):
				for column in columns: column.visible = True
			else:
				for column in columns: column.visible = False
		else:
			try:
				column = [column for column in columns if column.shortName == cmdStr[0]][0]
			except IndexError: pass
			else:
				column.visible = not column.visible
	
	start = end = None
	startMatch = re.match(r'(\d+)', cmdStr)
	if startMatch:
		start = int(startMatch.groups()[0])
		cmdStr = cmdStr[startMatch.end():].strip()
		endMatch = re.match(r'-(\d+)', cmdStr)
		if endMatch:
			end = int(endMatch.groups()[0])
			cmdStr = cmdStr[endMatch.end():].strip()
	arg = cmdStr
	
	if cmdName in itemCmds and (start != None) and not ((itemCmds[cmdName][1] == None) ^ (arg == '')):
		itemRange = range(start, end + 1)  if (end and end > start) else range(start, start + 1)
		if itemCmds[cmdName][1] == 'id': arg = ids[int(arg)]
		value2 = arg if (arg != '') else None		
		for i in itemRange:
			sendCmd(base, apiKey, itemCmds[cmdName][0], ids[i], value2)
	forceUpdate = True

def runQueueWin(base, apiKey, win):
	global ids, columns, forceUpdate, helpOn
	columns = initColumns()
	forceUpdate = False
	helpOn = False
	refreshInterval = datetime.timedelta(0, 3)
	while True:
		queue = sendCmd(base, apiKey, 'queue')['queue']
		ids = list()
		# Note: 15027d is an invalid age
		maxAvgAge = 0
		for item in queue['slots']:
			ids.append(item['nzo_id'])
			avgAge = item['avg_age'].split('d')
			if len(avgAge) == 2:
				avgAge = int(avgAge[0])
				if avgAge != 15027 and avgAge > maxAvgAge: maxAvgAge = avgAge
		cursY, cursX = curses.getsyx()
		printQueue(queue, win)
		if helpOn: printHelp(win)
		win.refresh()
		curses.setsyx(cursY, cursX)
		curses.doupdate()
		lastPrint = datetime.datetime.now()
		while datetime.datetime.now() - lastPrint < refreshInterval and not forceUpdate: pass
		forceUpdate = False

def main(base, apiKey):
	if not base and not apiKey:
		apiKey, port = _getConfig()
		base = 'localhost:%s' % port
	screen = curses.initscr()
	height, width = screen.getmaxyx()
	y, x = screen.getbegyx()
	queueWin = curses.newwin(height - 1, width, y, x)
	
	prompt = curses.newwin(1, 4, height - 1, 0)
	prompt.addstr(0, 0, '>>>')
	prompt.refresh()
	
	promptWin = curses.newwin(1, width - 4, height - 1, 4)
	
	qt = threading.Thread(None, runQueueWin, None, [base, apiKey, queueWin])
	qt.start()
	
	while True:
		promptWin.clear()
		promptWin.refresh()
		cmdStr = promptWin.getstr(0, 0)
		handleCmd(base, apiKey, cmdStr)

if __name__ == '__main__':
	if len(sys.argv) == 3:
		name, base, apiKey = sys.argv
	elif len(sys.argv) > 1:
		print 'Usage: %s SABnzbd-URL API-Key' % sys.argv[0]
		sys.exit(1)
	else:
		base = apiKey = None
		try: main(base, apiKey)
		finally: curses.endwin()
	
